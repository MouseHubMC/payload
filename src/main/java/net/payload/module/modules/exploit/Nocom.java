package net.payload.module.modules.exploit;

import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
import net.minecraft.util.Formatting;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.WorldChunk;
import net.payload.Payload;
import net.payload.event.events.ReceivePacketEvent;
import net.payload.event.events.TickEvent;
import net.payload.event.listeners.ReceivePacketListener;
import net.payload.event.listeners.SendPacketListener;
import net.payload.event.listeners.TickListener;
import net.payload.module.Category;
import net.payload.module.Module;
import net.payload.settings.types.BooleanSetting;
import net.payload.settings.types.FloatSetting;
import net.payload.utils.math.CacheTimer;

import java.util.ArrayList;
import java.util.List;

public class Nocom extends Module implements ReceivePacketListener, TickListener {

	public enum DotType {
		Spotted, Searched
	}

	public BooleanSetting chatLogs = BooleanSetting.builder()
			.id("nocom_chatlogs")
			.displayName("All Chat Logs")
			.defaultValue(false)
			.build();

	public BooleanSetting foundchatLogs = BooleanSetting.builder()
			.id("nocom_chatlogs")
			.displayName("Detected Chat Logs")
			.defaultValue(true)
			.build();

	public BooleanSetting nearTrack = BooleanSetting.builder()
			.id("nocom_nearby")
			.displayName("Nearby Only")
			.defaultValue(true)
			.build();

	public FloatSetting delay = FloatSetting.builder()
			.id("nocom_delay")
			.displayName("Delay")
			.defaultValue(250f)
			.minValue(0f)
			.maxValue(1000f)
			.step(50f)
			.build();

	public FloatSetting loop = FloatSetting.builder()
			.id("nocom_loop")
			.displayName("LoopPerTick")
			.defaultValue(1f)
			.minValue(1f)
			.maxValue(10f)
			.step(1f)
			.build();

	public Nocom() {
		super("Nocom");
		this.setCategory(Category.of("Exploit"));
		this.setDescription("Ancient paper exploit, patched but here for the lolz");

		this.addSetting(chatLogs);
		this.addSetting(foundchatLogs);
		this.addSetting(delay);
		this.addSetting(loop);
		this.addSetting(nearTrack);
	}

	public record Cout(int posY, String out) {}
	public record Dot(int posX, int posY, DotType type) {}

	private static int count, reRunStartX, reRunStartY, currentX, currentZ;
	public static List<Dot> dots = new ArrayList<>();
	private static BlockPos playerPos = null;
	private CacheTimer delayTimer = new CacheTimer();
	public static int scannedChunks = 0;
	public int couti = 1;
	private static boolean warning = true;

	public void rerun(int x, int y) {
		dots.clear();
		playerPos = null;
		count = 0;
		delayTimer.reset();
		reRunStartX = x;
		reRunStartY = y;
	}

	@Override
	public void onDisable() {
		Payload.getInstance().eventManager.RemoveListener(ReceivePacketListener.class, this);
		Payload.getInstance().eventManager.RemoveListener(TickListener.class, this);
		dots.clear();
		playerPos = null;
		count = 0;
	}

	@Override
	public void onEnable() {
		Payload.getInstance().eventManager.AddListener(ReceivePacketListener.class, this);
		Payload.getInstance().eventManager.AddListener(TickListener.class, this);
		if (warning) {
			sendErrorMessage("Please note that this exploit is patched on 99% of public paper servers now");
			sendErrorMessage("lol");
		}
		playerPos = null;
		count = 0;
	}

	@Override
	public void onToggle() {

	}

	@Override
	public void onReceivePacket(ReceivePacketEvent readPacketEvent) {
		if (nullCheck()) return;

		if (readPacketEvent.getPacket() instanceof BlockUpdateS2CPacket packet) {
			final int x = packet.getPos().getX();
			final int z = packet.getPos().getZ();
			for (Chunk chunk : getLoadedChunks())
				if (chunk.getPos().x == x / 16 || chunk.getPos().z == z / 16) return;
			String shittytext = ("Player spotted at X: ") + Formatting.GREEN + x + Formatting.RESET + " Z: " + Formatting.GREEN + z;
			dots.add(new Dot(x / 16, z / 16, DotType.Spotted));
			if (foundchatLogs.getValue()) {
				sendChatMessage(shittytext);
			}
			++couti;
			if (foundchatLogs.getValue()) {
				sendChatMessage(("Tracking players on X: ") + x + " Z: " + z);
			}
			++couti;
			rerun(x, z);
			//Managers.NOTIFICATION.publicity("NoCommentExploit", shittytext, 3, Notification.Type.INFO);
		}
	}

	@Override
	public void onTick(TickEvent.Pre event) {
		if (nullCheck()) return;

		if (nearTrack.getValue()) {
			if (scannedChunks > 25) {
				scannedChunks = 0;
			} else if (scannedChunks < 25) {
				doNocom((int) MC.player.getX(), (int) MC.player.getZ());
			}
		} else {
			// When nearTrack is disabled, if re-run coordinates are set, use those.
			if (reRunStartX != 0 && reRunStartY != 0) {
				doNocom(reRunStartX, reRunStartY);
			} else {
				doNocom((int) MC.player.getX(), (int) MC.player.getZ());
			}
		}
	}

	public void doNocom(int x3, int y3) {
		playerPos = BlockPos.ofFloored(MC.player.getX(), MC.player.getY() - 1, MC.player.getZ());

		if (delayTimer.passed(delay.getValue())) {
			for (int i = 0; i < loop.getValue(); i++) {

				int x1 = getSpiralCoords(count)[0] * 128 + x3;
				int z1 = getSpiralCoords(count)[1] * 128 + y3;

				final BlockPos position = new BlockPos(x1, 0, z1);
				currentX = x1;
				currentZ = z1;
				sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, playerPos, Direction.EAST));
				sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, position, Direction.EAST));

				if (chatLogs.getValue()) {
					sendChatMessage("Sent Packet to : " + position.getX() + "X, " + position.getY() + "Y, " + position.getZ() + "Z");
				}

				dots.add(new Dot(x1 / 16, z1 / 16, DotType.Searched));
				playerPos = BlockPos.ofFloored(MC.player.getX(), MC.player.getY() - 1, MC.player.getZ());
				delayTimer.reset();
				count++;
				++scannedChunks;
			}
		}
	}

	public static List<WorldChunk> getLoadedChunks() {
		List<WorldChunk> chunks = new ArrayList<>();
		int viewDist = MC.options.getViewDistance().getValue();
		for (int x = -viewDist; x <= viewDist; x++) {
			for (int z = -viewDist; z <= viewDist; z++) {
				WorldChunk chunk = MC.world.getChunkManager().getWorldChunk((int) MC.player.getX() / 16 + x, (int) MC.player.getZ() / 16 + z);

				if (chunk != null) chunks.add(chunk);
			}
		}
		return chunks;
	}

	private int[] getSpiralCoords(int n) {
		int x = 0;
		int z = 0;
		int d = 1;
		int lineNumber = 1;
		int[] coords = {0, 0};
		for (int i = 0; i < n; i++) {
			if (2 * x * d < lineNumber) {
				x += d;
				coords = new int[]{x, z};
			} else if (2 * z * d < lineNumber) {
				z += d;
				coords = new int[]{x, z};
			} else {
				d *= -1;
				lineNumber++;
				n++;
			}
		}
		return coords;
	}

	protected void sendPacket(Packet<?> packet) {
		if (MC.getNetworkHandler() == null) return;

		MC.getNetworkHandler().sendPacket(packet);
	}

	@Override
	public void onTick(TickEvent.Post event) {

	}
}
