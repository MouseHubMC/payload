package net.payload.module.modules.exploit;

import net.minecraft.block.entity.TrialSpawnerBlockEntity;
import net.minecraft.block.enums.TrialSpawnerState;
import net.minecraft.block.spawner.MobSpawnerLogic;
import net.minecraft.entity.vehicle.ChestMinecartEntity;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.world.World;
import net.minecraft.world.chunk.WorldChunk;
import net.payload.Payload;
import net.payload.event.events.GameLeftEvent;
import net.payload.event.events.Render3DEvent;
import net.payload.event.events.TickEvent;
import net.payload.event.events.TickEvent.Pre;
import net.payload.event.listeners.GameLeftListener;
import net.payload.event.listeners.Render3DListener;
import net.payload.event.listeners.TickListener;
import net.payload.gui.colors.Color;
import net.payload.module.Category;
import net.payload.module.Module;
import net.payload.settings.types.*;
import net.minecraft.block.Blocks;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.block.entity.MobSpawnerBlockEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Vec3d;
import net.payload.utils.render.Render3D;

import java.util.*;

public class SpawnerScan extends Module implements TickListener, Render3DListener, GameLeftListener {

    public final BooleanSetting trialSpawner = BooleanSetting.builder()
                .id("ASD_trial_spawner_detector")
                .displayName("Show Trials")
                .defaultValue(true)
                .build();

    public final BooleanSetting enableDungeon = BooleanSetting.builder()
            .id("ASD_dungeon_detector")
            .displayName("Show Dungeons")
            .defaultValue(true)
            .build();

    public final BooleanSetting enableMineshaft = BooleanSetting.builder()
            .id("ASD_mineshaft_detector")
            .displayName("Show Mineshafts")
            .defaultValue(true)
            .build();

    public final BooleanSetting enableMisc = BooleanSetting.builder()
            .id("ASD_misc")
            .displayName("Show Misc")
            .defaultValue(true)
            .build();

    public final BooleanSetting chatFeedback = BooleanSetting.builder()
            .id("ASD_chatfeedback")
            .displayName("Chat Feedback")
            .defaultValue(true)
            .build();

    public final BooleanSetting displaycoords = BooleanSetting.builder()
            .id("ASD_displaycoords")
            .displayName("DisplayCoords")
            .defaultValue(true)
            .build();

    public final BooleanSetting extramessage = BooleanSetting.builder()
            .id("ASD_extramessage")
            .displayName("Stash Message")
            .defaultValue(true)
            .build();

    public final BooleanSetting lessSpam = BooleanSetting.builder()
            .id("ASD_lessSpam")
            .displayName("Less Stash Spam")
            .defaultValue(true)
            .build();

    public final BooleanSetting airChecker = BooleanSetting.builder()
            .id("ASD_airchecker")
            .displayName("Air Check")
            .defaultValue(false)
            .build();

    public final BooleanSetting accountForAllStorage = BooleanSetting.builder()
            .id("ASD_accountforallstorage")
            .displayName("Chest Check")
            .defaultValue(true)
            .build();

    public final BooleanSetting deactivatedSpawner = BooleanSetting.builder()
            .id("ASD_deactivated_spawners")
            .displayName("Show Inactive Spawners")
            .defaultValue(true)
            .build();

    public final FloatSetting deactivatedSpawnerdistance = FloatSetting.builder()
            .id("ASD_torch_scan_distance")
            .displayName("Torch Scan Dist")
            .defaultValue(1f)
            .minValue(1f)
            .maxValue(10f)
            .step(1f)
            .build();

    public final BooleanSetting lessRenderSpam = BooleanSetting.builder()
            .id("ASD_lessrenderspam")
            .displayName("Less Render Spam")
            .defaultValue(true)
            .build();

    public final FloatSetting renderDistance = FloatSetting.builder()
            .id("ASD_renderdistance")
            .displayName("Render Distance")
            .defaultValue(32f)
            .minValue(6f)
            .maxValue(100f)
            .step(2f)
            .build();

    public final BooleanSetting removerenderdist = BooleanSetting.builder()
            .id("ASD_removerenderdist")
            .displayName("Render Dist Check")
            .defaultValue(true)
            .build();

    private ColorSetting spawnerSideColor = ColorSetting.builder()
            .id("ASD_spawnersidecolor")
            .displayName("Spawner Color")
            .defaultValue(new Color(255, 5, 5, 70))
            .build();


    private ColorSetting despawnerSideColor = ColorSetting.builder()
            .id("ASD_despawnersidecolor")
            .displayName("Idle Spawner Color")
            .defaultValue(new Color(255, 5, 255, 70))
            .build();

    public final BooleanSetting rangerendering = BooleanSetting.builder()
            .id("ASD_rangerendering")
            .displayName("Range Rendering")
            .defaultValue(true)
            .build();

    private ColorSetting rangeSideColor = ColorSetting.builder()
            .id("ASD_rangesidecolor")
            .displayName("Range Color")
            .defaultValue(new Color(0, 255, 0, 30))
            .build();

    public FloatSetting lineThickness = FloatSetting.builder()
            .id("ASD_thickness")
            .displayName("Line Thickness")
            .defaultValue(0.5f)
            .minValue(0f)
            .maxValue(5f)
            .step(0.1f)
            .build();

    public SpawnerScan() {
        super("SpawnerScan");
        this.setCategory(Category.of("Exploit"));
        this.setDescription("Detects activated spawners and renders/records their location");

        this.addSetting(trialSpawner);
        this.addSetting(enableDungeon);
        this.addSetting(enableMineshaft);
        this.addSetting(enableMisc);
        this.addSetting(chatFeedback);
        this.addSetting(displaycoords);
        this.addSetting(extramessage);
        this.addSetting(lessSpam);
        this.addSetting(airChecker);
        this.addSetting(accountForAllStorage);
        this.addSetting(deactivatedSpawner);
        this.addSetting(deactivatedSpawnerdistance);
        this.addSetting(lessRenderSpam);
        this.addSetting(renderDistance);
        this.addSetting(removerenderdist);
        this.addSetting(spawnerSideColor);
        this.addSetting(despawnerSideColor);
        this.addSetting(rangerendering);
        this.addSetting(rangeSideColor);
        this.addSetting(lineThickness);
    }

    private final Set<BlockPos> scannedPositions = Collections.synchronizedSet(new HashSet<>());
    private final Set<BlockPos> spawnerPositions = Collections.synchronizedSet(new HashSet<>());
    private final Set<BlockPos> trialspawnerPositions = Collections.synchronizedSet(new HashSet<>());
    private final Set<BlockPos> deactivatedSpawnerPositions = Collections.synchronizedSet(new HashSet<>());
    private final Set<BlockPos> noRenderPositions = Collections.synchronizedSet(new HashSet<>());
    private int closestSpawnerX=2000000000;
    private int closestSpawnerY=2000000000;
    private int closestSpawnerZ=2000000000;
    private double SpawnerDistance=2000000000;
    private boolean activatedSpawnerFound = false;
    private boolean warning = true;
    @Override
    public void onGameLeft(GameLeftEvent event) {
        clearChunkData();
    }

    private void clearChunkData(){
        scannedPositions.clear();
        spawnerPositions.clear();
        deactivatedSpawnerPositions.clear();
        noRenderPositions.clear();
        trialspawnerPositions.clear();
        closestSpawnerX=2000000000;
        closestSpawnerY=2000000000;
        closestSpawnerZ=2000000000;
        SpawnerDistance=2000000000;
    }

    private void displayMessage(String key, BlockPos pos, String key2) {
        if (chatFeedback.get()){
            if (key=="dungeon") {
                if (key2==":spider") {
                    if (MC.world.getBlockState(pos.down()).getBlock() == Blocks.BIRCH_PLANKS && enableMisc.get()){
                        activatedSpawnerFound = true;
                        spawnerPositions.add(pos);
                        if (displaycoords.get()) sendChatMessage(("Detected Activated Woodland Mansion at Position: " + pos));
                        else sendChatMessage(("Detected Activated Woodland Mansion"));
                    } else {
                        if (enableDungeon.get()){
                            activatedSpawnerFound = true;
                            spawnerPositions.add(pos);
                            if (displaycoords.get()) sendChatMessage(("Detected Activated Dungeon at Position: " + pos));
                            else sendChatMessage(("Detected Activated Dungeon"));
                        }
                    }
                } else {
                    if (enableDungeon.get()){
                        activatedSpawnerFound = true;
                        spawnerPositions.add(pos);
                        if (displaycoords.get()) sendChatMessage(("Detected Activated Dungeon at Position: " + pos));
                        else sendChatMessage(("Detected Activated Dungeon"));
                    }
                }
            } else if (key=="cave_spider" && enableMineshaft.get()) {
                activatedSpawnerFound = true;
                spawnerPositions.add(pos);
                if (displaycoords.get()) sendChatMessage(("Detected Activated Mineshaft at Position: " + pos));
                else sendChatMessage("Detected Activated Mineshaft");
            } else if (key=="silverfish" && enableMisc.get()) {
                activatedSpawnerFound = true;
                spawnerPositions.add(pos);
                if (displaycoords.get()) sendChatMessage(("Detected Activated Stronghold at Position: " + pos));
                else sendChatMessage(("Detected Activated Stronghold"));
            } else if (key=="blaze" && enableMisc.get()) {
                activatedSpawnerFound = true;
                spawnerPositions.add(pos);
                if (displaycoords.get()) sendChatMessage(("Detected Activated Fortress at Position: " + pos));
                else sendChatMessage(("Detected Activated Fortress"));
            } else if (key=="magma" && enableMisc.get()) {
                activatedSpawnerFound = true;
                spawnerPositions.add(pos);
                if (displaycoords.get()) sendChatMessage(("Detected Activated Bastion at Position: " + pos));
                else sendChatMessage(("Detected Activated Bastion"));
            } else {
                activatedSpawnerFound = true;
                spawnerPositions.add(pos);
                if (displaycoords.get()) sendChatMessage(("Detected Activated Spawner at Position: " + pos));
                else sendChatMessage(("Detected Activated Spawner"));
            }
        }
    }

    @Override
    public void onDisable() {
        Payload.getInstance().eventManager.RemoveListener(TickListener.class, this);
        Payload.getInstance().eventManager.RemoveListener(Render3DListener.class, this);
        Payload.getInstance().eventManager.RemoveListener(GameLeftListener.class, this);
        clearChunkData();
    }

    @Override
    public void onEnable() {
        Payload.getInstance().eventManager.AddListener(TickListener.class, this);
        Payload.getInstance().eventManager.AddListener(Render3DListener.class, this);
        Payload.getInstance().eventManager.AddListener(GameLeftListener.class, this);
        clearChunkData();
    }

    @Override
    public void onToggle() {

    }

    @Override
    public void onTick(Pre event) {
        if (nullCheck()) return;

        if (warning && airChecker.get()) {
            sendErrorMessage("Warning: air checker can occasionally produce false positives");
            warning = false;
        }

        int renderdistance = MC.options.getViewDistance().getValue();
        ChunkPos playerChunkPos = new ChunkPos(MC.player.getBlockPos());
        for (int chunkX = playerChunkPos.x - renderdistance; chunkX <= playerChunkPos.x + renderdistance; chunkX++) {
            for (int chunkZ = playerChunkPos.z - renderdistance; chunkZ <= playerChunkPos.z + renderdistance; chunkZ++) {
                WorldChunk chunk = MC.world.getChunk(chunkX, chunkZ);
                List<BlockEntity> blockEntities = new ArrayList<>(chunk.getBlockEntities().values());

                for (BlockEntity blockEntity : blockEntities) {
                    if (blockEntity instanceof MobSpawnerBlockEntity){
                        activatedSpawnerFound = false;
                        MobSpawnerBlockEntity spawner = (MobSpawnerBlockEntity) blockEntity;
                        MobSpawnerLogic logic = spawner.getLogic(); // Get the logic instance

                        BlockPos pos = spawner.getPos();
                        BlockPos playerPos = new BlockPos(MC.player.getBlockX(), pos.getY(), MC.player.getBlockZ());
                        String monster = null;
                        if (spawner.getLogic().spawnEntry != null && spawner.getLogic().spawnEntry.getNbt().get("id") != null) monster = spawner.getLogic().spawnEntry.getNbt().get("id").toString();
                        if (playerPos.isWithinDistance(pos, renderDistance.get() * 16) && !trialspawnerPositions.contains(pos) && !noRenderPositions.contains(pos) && !deactivatedSpawnerPositions.contains(pos) && !spawnerPositions.contains(pos)){
                            if (airChecker.get() && (spawner.getLogic().spawnDelay == 20 || spawner.getLogic().spawnDelay == 0)){
                                boolean airFound = false;
                                boolean caveAirFound = false;
                                if (monster != null && !scannedPositions.contains(pos)){
                                    if (monster.contains("zombie") || monster.contains("skeleton") || monster.contains(":spider")) {
                                        for (int x = -2; x < 2; x++) {
                                            for (int y = -1; y < 3; y++) {
                                                for (int z = -2; z < 2; z++) {
                                                    BlockPos bpos = new BlockPos(pos.getX()+x,pos.getY()+y,pos.getZ()+z);
                                                    if (MC.world.getBlockState(bpos).getBlock() == Blocks.AIR) airFound = true;
                                                    if (MC.world.getBlockState(bpos).getBlock() == Blocks.CAVE_AIR) caveAirFound = true;
                                                    if (caveAirFound && airFound) break;
                                                }
                                            }
                                        }
                                        if (caveAirFound && airFound) {
                                            if (monster == ":spider") displayMessage("dungeon", pos, ":spider");
                                            else displayMessage("dungeon", pos, "null");
                                        }
                                    } else if (monster.contains("cave_spider")) {
                                        for (int x = -1; x < 2; x++) {
                                            for (int y = 0; y < 2; y++) {
                                                for (int z = -1; z < 2; z++) {
                                                    BlockPos bpos = new BlockPos(pos.getX()+x,pos.getY()+y,pos.getZ()+z);
                                                    if (MC.world.getBlockState(bpos).getBlock() == Blocks.AIR) airFound = true;
                                                    if (MC.world.getBlockState(bpos).getBlock() == Blocks.CAVE_AIR) caveAirFound = true;
                                                    if (caveAirFound && airFound) break;
                                                }
                                            }
                                        }
                                        if (caveAirFound && airFound) {
                                            displayMessage("cave_spider", pos, "null");
                                        }
                                    } else if (monster.contains("silverfish")) {
                                        for (int x = -3; x < 3+1; x++) {
                                            for (int y = -2; y < 3+1; y++) {
                                                for (int z = -3; z < 3+1; z++) {
                                                    BlockPos bpos = new BlockPos(pos.getX()+x,pos.getY()+y,pos.getZ()+z);
                                                    if (MC.world.getBlockState(bpos).getBlock() == Blocks.AIR) airFound = true;
                                                    if (MC.world.getBlockState(bpos).getBlock() == Blocks.CAVE_AIR) caveAirFound = true;
                                                    if (caveAirFound && airFound) break;
                                                }
                                            }
                                        }
                                        if (caveAirFound && airFound) {
                                            displayMessage("silverfish", pos, "null");
                                        }
                                    }
                                }
                                scannedPositions.add(pos);
                            } else if (spawner.getLogic().spawnDelay != 20) {
                                if (MC.world.getRegistryKey() == World.NETHER && spawner.getLogic().spawnDelay == 0) return;
                                if (chatFeedback.get()) {
                                    if (monster != null){
                                        if (monster.contains("zombie") || monster.contains("skeleton") || monster.contains(":spider")) {
                                            if (monster == ":spider") displayMessage("dungeon", pos, ":spider");
                                            else displayMessage("dungeon", pos, "null");
                                        } else if (monster.contains("cave_spider")) {
                                            displayMessage("cave_spider", pos, "null");
                                        } else if (monster.contains("silverfish")) {
                                            displayMessage("silverfish", pos, "null");
                                        } else if (monster.contains("blaze")) {
                                            displayMessage("blaze", pos, "null");
                                        } else if (monster.contains("magma")) {
                                            displayMessage("magma", pos, "null");
                                        } else {
                                            if (displaycoords.get()) sendChatMessage(("Detected Activated Spawner! Block Position: " + pos));
                                            else sendChatMessage(("Detected Activated Spawner!"));
                                            spawnerPositions.add(pos);
                                            activatedSpawnerFound = true;
                                        }
                                    } else {
                                        if (displaycoords.get()) sendChatMessage(("Detected Activated Spawner! Block Position: " + pos));
                                        else sendChatMessage(("Detected Activated Spawner!"));
                                        spawnerPositions.add(pos);
                                        activatedSpawnerFound = true;
                                    }
                                }
                            }
                            if (activatedSpawnerFound) {
                                if (deactivatedSpawner.get()){
                                    boolean lightsFound = false;
                                    for (int x = (int) -deactivatedSpawnerdistance.get(); x < deactivatedSpawnerdistance.get()+1; x++) {
                                        for (int y = (int) -deactivatedSpawnerdistance.get(); y < deactivatedSpawnerdistance.get()+1; y++) {
                                            for (int z = (int) -deactivatedSpawnerdistance.get(); z < deactivatedSpawnerdistance.get()+1; z++) {
                                                BlockPos bpos = new BlockPos(pos.getX()+x,pos.getY()+y,pos.getZ()+z);
                                                if (MC.world.getBlockState(bpos).getBlock() == Blocks.TORCH || MC.world.getBlockState(bpos).getBlock() == Blocks.SOUL_TORCH || MC.world.getBlockState(bpos).getBlock() == Blocks.REDSTONE_TORCH || MC.world.getBlockState(bpos).getBlock() == Blocks.JACK_O_LANTERN || MC.world.getBlockState(bpos).getBlock() == Blocks.GLOWSTONE || MC.world.getBlockState(bpos).getBlock() == Blocks.SHROOMLIGHT || MC.world.getBlockState(bpos).getBlock() == Blocks.OCHRE_FROGLIGHT || MC.world.getBlockState(bpos).getBlock() == Blocks.PEARLESCENT_FROGLIGHT || MC.world.getBlockState(bpos).getBlock() == Blocks.PEARLESCENT_FROGLIGHT || MC.world.getBlockState(bpos).getBlock() == Blocks.SEA_LANTERN || MC.world.getBlockState(bpos).getBlock() == Blocks.LANTERN || MC.world.getBlockState(bpos).getBlock() == Blocks.SOUL_LANTERN || MC.world.getBlockState(bpos).getBlock() == Blocks.CAMPFIRE || MC.world.getBlockState(bpos).getBlock() == Blocks.SOUL_CAMPFIRE){
                                                    lightsFound = true;
                                                    deactivatedSpawnerPositions.add(pos);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (chatFeedback.get() && lightsFound) sendChatMessage(("This Spawner has torches or other light blocks"));
                                }

                                boolean chestfound = false;
                                for (int x = -16; x < 17; x++) {
                                    for (int y = -16; y < 17; y++) {
                                        for (int z = -16; z < 17; z++) {
                                            BlockPos bpos = new BlockPos(pos.getX()+x, pos.getY()+y, pos.getZ()+z);
                                            if (accountForAllStorage.get()) {
                                                chestfound = true;
                                                break;
                                            }
                                            Box box = new Box(bpos);
                                            List<ChestMinecartEntity> minecarts = MC.world.getEntitiesByClass(ChestMinecartEntity.class, box, entity -> true);
                                            if (!minecarts.isEmpty()) {
                                                chestfound = true;
                                                break;
                                            }
                                        }
                                        if (chestfound) break;
                                    }
                                    if (chestfound) break;
                                }
                                if (!chestfound && lessRenderSpam.get()){
                                    noRenderPositions.add(pos);
                                }
                                if (chatFeedback.get()) {
                                    if (lessSpam.get() && chestfound && extramessage.get()) sendChatMessage("There may be stashed items in the storage near the spawners");
                                    else if (!lessSpam.get() && extramessage.get()) sendChatMessage("There may be stashed items in the storage near the spawners");
                                }
                            }
                        }
                    }
                    if (blockEntity instanceof TrialSpawnerBlockEntity){
                        TrialSpawnerBlockEntity trialspawner = (TrialSpawnerBlockEntity) blockEntity;
                        BlockPos tPos = trialspawner.getPos();
                        BlockPos playerPos = new BlockPos(MC.player.getBlockX(), tPos.getY(), MC.player.getBlockZ());
                        if (playerPos.isWithinDistance(tPos, renderDistance.get() * 16) && trialSpawner.get() && !trialspawnerPositions.contains(tPos) && !noRenderPositions.contains(tPos) && !deactivatedSpawnerPositions.contains(tPos) && !spawnerPositions.contains(tPos) && trialspawner.getSpawnerState() != TrialSpawnerState.WAITING_FOR_PLAYERS) {
                            if (chatFeedback.get()) {
                                if (displaycoords.get()) sendChatMessage(("Detected Activated Trial Spawner at Position: " + tPos));
                                else sendChatMessage(("Detected Activated Trail Spawner"));
                            }
                            trialspawnerPositions.add(tPos);
                            boolean chestfound = false;
                            for (int x = -14; x < 15; x++) {
                                for (int y = -14; y < 15; y++) {
                                    for (int z = -14; z < 15; z++) {
                                        BlockPos bpos = new BlockPos(tPos.getX()+x, tPos.getY()+y, tPos.getZ()+z);
                                        if (accountForAllStorage.get()) {
                                            chestfound = true;
                                            break;
                                        }
                                        Box box = new Box(bpos);
                                        List<ChestMinecartEntity> minecarts = MC.world.getEntitiesByClass(ChestMinecartEntity.class, box, entity -> true);
                                        if (!minecarts.isEmpty()) {
                                            chestfound = true;
                                            break;
                                        }
                                    }
                                    if (chestfound) break;
                                }
                                if (chestfound) break;
                            }
                            if (!chestfound && lessRenderSpam.get()){
                                noRenderPositions.add(tPos);
                            }
                            if (chatFeedback.get()) {
                                if (lessSpam.get() && chestfound && extramessage.get()) sendChatMessage("There may be stashed items in the storage near the spawners!");
                                else if (!lessSpam.get() && extramessage.get()) sendChatMessage("There may be stashed items in the storage near the spawners!");
                            }
                        }
                    }
                }
            }
        }
        if (removerenderdist.get())removeChunksOutsideRenderDistance();
    }

    private void removeChunksOutsideRenderDistance() {
        double renderDistanceBlocks = renderDistance.get() * 16;

        removeChunksOutsideRenderDistance(scannedPositions, renderDistanceBlocks);
        removeChunksOutsideRenderDistance(spawnerPositions, renderDistanceBlocks);
        removeChunksOutsideRenderDistance(deactivatedSpawnerPositions, renderDistanceBlocks);
        removeChunksOutsideRenderDistance(trialspawnerPositions, renderDistanceBlocks);
        removeChunksOutsideRenderDistance(noRenderPositions, renderDistanceBlocks);
    }
    private void removeChunksOutsideRenderDistance(Set<BlockPos> chunkSet, double renderDistanceBlocks) {
        chunkSet.removeIf(blockPos -> {
            BlockPos playerPos = new BlockPos(MC.player.getBlockX(), blockPos.getY(), MC.player.getBlockZ());
            return !playerPos.isWithinDistance(blockPos, renderDistanceBlocks);
        });
    }

    @Override
    public void onTick(TickEvent.Post event) {

    }

    private void render(Box box, Color sides, Render3DEvent event) {
        Render3D.draw3DBox(event.GetMatrix(), event.getCamera(), box, sides, lineThickness.getValue());
    }
    private void render2(Box box, Color sides, Render3DEvent event) {
        Render3D.draw3DBox(event.GetMatrix(), event.getCamera(), box, sides, lineThickness.getValue());
    }
    private void renderRange(Box box, Color sides, Render3DEvent event) {
        Render3D.draw3DBox(event.GetMatrix(), event.getCamera(), box, sides, lineThickness.getValue());
    }

    @Override
    public void onRender(Render3DEvent event) {
        if (nullCheck()) return;

        if (spawnerSideColor.get().getAlphaInt() > 5 || rangeSideColor.get().getAlphaInt() > 5) {
            synchronized (spawnerPositions) {
                for (BlockPos pos : spawnerPositions) {
                    BlockPos playerPos = new BlockPos(MC.player.getBlockX(), pos.getY(), MC.player.getBlockZ());
                    if (pos != null && playerPos.isWithinDistance(pos, renderDistance.get() * 16)) {
                        int startX = pos.getX();
                        int startY = pos.getY();
                        int startZ = pos.getZ();
                        int endX = pos.getX();
                        int endY = pos.getY();
                        int endZ = pos.getZ();
                            if (rangerendering.get() && !lessRenderSpam.get())
                                renderRange(new Box(new Vec3d(startX + 17, startY + 17, startZ + 17), new Vec3d(endX - 16, endY - 16, endZ - 16)), rangeSideColor.get(), event);
                            else if (rangerendering.get() && lessRenderSpam.get() && !noRenderPositions.contains(pos))
                                renderRange(new Box(new Vec3d(startX + 17, startY + 17, startZ + 17), new Vec3d(endX - 16, endY - 16, endZ - 16)), rangeSideColor.get(), event);
                            if (deactivatedSpawnerPositions.contains(pos))
                                render(new Box(new Vec3d(startX + 1, startY + 1, startZ + 1), new Vec3d(endX, endY, endZ)), despawnerSideColor.get(), event);
                            else
                                render(new Box(new Vec3d(startX + 1, startY + 1, startZ + 1), new Vec3d(endX, endY, endZ)), spawnerSideColor.get(), event);
                    }
                }
            }
            synchronized (trialspawnerPositions) {
                for (BlockPos pos : trialspawnerPositions) {
                    BlockPos playerPos = new BlockPos(MC.player.getBlockX(), pos.getY(), MC.player.getBlockZ());
                    if (pos != null && playerPos.isWithinDistance(pos, renderDistance.get() * 16)) {
                        int startX = pos.getX();
                        int startY = pos.getY();
                        int startZ = pos.getZ();
                        int endX = pos.getX();
                        int endY = pos.getY();
                        int endZ = pos.getZ();
                            if (trialSpawner.get() && rangerendering.get() && !lessRenderSpam.get())renderRange(new Box(new Vec3d(startX+15, startY+15, startZ+15), new Vec3d(endX-14, endY-14, endZ-14)), rangeSideColor.get(), event);
                            else if (trialSpawner.get() && rangerendering.get() && lessRenderSpam.get() && !noRenderPositions.contains(pos))renderRange(new Box(new Vec3d(startX+15, startY+15, startZ+15), new Vec3d(endX-14, endY-14, endZ-14)), rangeSideColor.get(), event);
                            if (deactivatedSpawnerPositions.contains(pos)) render(new Box(new Vec3d(startX+1, startY+1, startZ+1), new Vec3d(endX, endY, endZ)), despawnerSideColor.get(), event);
                            else render(new Box(new Vec3d(startX+1, startY+1, startZ+1), new Vec3d(endX, endY, endZ)), spawnerSideColor.get(), event);
                            if (trialSpawner.get() && rangerendering.get() && !lessRenderSpam.get())renderRange(new Box(new Vec3d(startX+15, startY+15, startZ+15), new Vec3d(endX-14, endY-14, endZ-14)), rangeSideColor.get(), event);
                            else if (trialSpawner.get() && rangerendering.get() && lessRenderSpam.get() && !noRenderPositions.contains(pos))renderRange(new Box(new Vec3d(startX+15, startY+15, startZ+15), new Vec3d(endX-14, endY-14, endZ-14)), rangeSideColor.get(), event);
                            if (deactivatedSpawnerPositions.contains(pos)) render(new Box(new Vec3d(startX+1, startY+1, startZ+1), new Vec3d(endX, endY, endZ)), despawnerSideColor.get(), event);
                            else render(new Box(new Vec3d(startX+1, startY+1, startZ+1), new Vec3d(endX, endY, endZ)), spawnerSideColor.get(), event);
                            render2(new Box(new Vec3d(closestSpawnerX, closestSpawnerY, closestSpawnerZ), new Vec3d (closestSpawnerX, closestSpawnerY, closestSpawnerZ)), spawnerSideColor.get(), event);
                    }
                }
            }
        }
    }
}